# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Column to Pair Nested Transformation
#'
#' @description
#' A sophisticated data transformation tool for generating column pair combinations 
#' and creating nested data structures with advanced configuration options.
#'
#' @param data Input 'data frame' or 'data table'
#'   - Must contain valid columns for transformation
#'   - Supports multiple data types
#'
#' @param cols2bind 'character' vector of column names for pair generation
#'   - Specifies target columns for combination
#'   - Must be existing columns in the dataset
#'
#' @param by Optional 'character' vector for grouping
#'   - Enables hierarchical nested transformations
#'   - Supports multi-level aggregation
#'   - Default is `NULL`
#'
#' @param pairs_n 'numeric' indicating combination size
#'   - Minimum value: 2
#'   - Maximum value: Length of `cols2bind`
#'   - Controls column pair complexity
#'   - Default is 2
#'
#' @param sep 'character' separator for pair naming
#'   - Used in generating combination identifiers
#'   - Must be a single character
#'   - Default is "-"
#'
#' @param nest_type Output nesting format
#'   - `'dt'`: Returns nested 'data table' (default)
#'   - `'df'`: Returns nested 'data frame'
#'
#' @details
#' Advanced Transformation Mechanism:
#' \enumerate{
#'   \item Input validation and preprocessing
#'   \item Dynamic column combination generation
#'   \item Flexible pair transformation
#'   \item Nested data structure creation
#' }
#'
#' Transformation Process:
#' \itemize{
#'   \item Validate input parameters
#'   \item Generate column combinations
#'   \item Create subset data tables
#'   \item Merge and nest transformed data
#' }
#'
#' Combination Strategy:
#' \itemize{
#'   \item Supports variable-length column combinations
#'   \item Generates all possible column pair permutations
#'   \item Maintains original data context
#' }
#'
#' @return 'data table' containing nested transformation results
#'   - Includes 'pairs' column identifying column combinations
#'   - Contains 'data' column storing nested data structures
#'   - Supports optional grouping variables
#'
#' @note Key Operation Constraints:
#' \itemize{
#'   \item Requires non-empty input data
#'   \item `cols2bind` must specify existing columns
#'   \item Supports flexible combination strategies
#'   \item Computational complexity increases with combination size
#' }
#'
#' @seealso
#' \itemize{
#'   \item [`utils::combn()`] Combination generation
#'   \item [`data.table::rbindlist()`] List binding utility
#'   \item [`data.table::copy()`] Data copying mechanism
#' }
#'
#' @import data.table
#' @importFrom utils combn
#' @export
#' @examples
#' col_names <- c("Sepal.Length", "Sepal.Width", "Petal.Length")
#' c2p_nest(iris, cols2bind = col_names, pairs_n = 2, sep = "&")
#' c2p_nest(iris, cols2bind = col_names, pairs_n = 2, by = "Species")
c2p_nest <- function(data, cols2bind, by = NULL, pairs_n = 2, sep = "-", nest_type = "dt") {
  . <- pairs <- NULL  # For data.table's NSE
  
  # Validate inputs
  if (!inherits(data, c("data.table", "data.frame"))) {
    stop("data must be a data.table or a data.frame")
  }
  data <- data.table::as.data.table(data)
  
  if (!is.character(cols2bind)) {
    stop("cols2bind must be a character vector")
  }
  missing_cols <- cols2bind[!cols2bind %in% names(data)]
  if (length(missing_cols) > 0) {
    stop("Some columns specified in cols2bind are not present in the data: ", paste(missing_cols, collapse=", "))
  }
  
  # Validate pairs_n
  if (!is.numeric(pairs_n) || pairs_n < 2 || floor(pairs_n) != pairs_n) {
    stop("pairs_n must be a positive integer greater than or equal to 2")
  }
  
  # Check if pairs_n is less than or equal to the number of available columns
  if (pairs_n > length(cols2bind)) {
    stop(sprintf("pairs_n (%d) cannot be larger than the number of available columns (%d)", 
                 pairs_n, length(cols2bind)))
  }
  
  if (!is.character(sep) || length(sep) != 1) {
    stop("sep must be a single character string")
  }
  
  if (!is.null(by)) {
    if (!is.character(by)) {
      stop("'by' must be a character vector of column names.")
    }
    missing_by_vars <- by[!by %in% names(data)]
    if (length(missing_by_vars) > 0) {
      stop("Grouping variables not present in data: ", paste(missing_by_vars, collapse=", "))
    }
  }
  
  if (!nest_type %in% c("dt", "df")) {
    stop("Invalid nest_type provided. It must be either 'dt' or 'df'.")
  }
  
  # Prepare data for combination operations
  dt <- data.table::copy(data)  # Copy the data to avoid modifying the original
  
  fixed_cols <- setdiff(names(dt), cols2bind)
  comb_cols_list <- combn(cols2bind, pairs_n, simplify=FALSE)
  
  list_of_dts <- lapply(comb_cols_list, function(comb) {
    dt_subset <- dt[, c(fixed_cols, comb), with=FALSE]
    # Create pairs identifier
    pairs_name <- paste(comb, collapse=sep)
    # Rename the combination columns to 'value1', 'value2', etc.
    data.table::setnames(dt_subset, comb, paste0('value', seq_along(comb)))
    # Add 'pairs' column
    dt_subset[, pairs := pairs_name]
    dt_subset
  })
  
  dt_bind <- data.table::rbindlist(list_of_dts)
  
  # Determine grouping variables
  if (!is.null(by) && length(by) > 0) {
    groupby <- c("pairs", by)
  } else {
    groupby <- "pairs"
  }
  
  # Nest the data based on nest_type
  if (nest_type == "dt") {
    result <- dt_bind[, .(data = list(.SD)), by = groupby]
  } else if (nest_type == "df") {
    result <- dt_bind[, .(data = list(as.data.frame(.SD))), by = groupby]
  } else {
    stop("Invalid nest_type provided. It must be either 'dt' or 'df'.")
  }
  
  return(result)
}
