# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Generate and Combine Pairs of Columns and Nest Data
#' 
#' The `combn_pair` function generates combinations of specified columns, combines them, and nests the data by the specified columns. It supports both `data.table` and `data.frame` inputs and allows for optional grouping.
#' 
#' @param data data.table or data.frame. The input data.
#' @param cols_bind character vector. The columns to combine into pairs.
#' @param by character vector, optional. Columns to group by. Default is NULL.
#' @param pairs_n integer, optional. The number of columns to include in each combination. Default is 2.
#' @param sep character, optional. The separator to use when combining column names. Default is "-".
#'
#' @return data.table. A nested data.table with combined column pairs.
#' \itemize{
#'   \item If `by` is NULL, returns a data.table nested by 'pairs'.
#'   \item If `by` is specified, returns a data.table nested by 'pairs' and the grouping variables.
#' }
#' 
#' @import data.table
#' @importFrom utils "combn"
#' 
#' @export
#' 
#' @note
#' \itemize{
#'   \item The `cols_bind` parameter must be a character vector of column names.
#'   \item The `pairs_n` parameter must be a positive integer greater than or equal to 2.
#'   \item The `sep` parameter must be a single character string.
#'   \item Ensure all grouping variables specified in `by` are present in the data.
#' }
#' @examples
#' col_names <- c("Sepal.Length", "Sepal.Width", "Petal.Length")
#' combn_pair(iris, cols_bind = col_names, pairs_n = 2, sep = "&")
#' combn_pair(iris, cols_bind = col_names, pairs_n = 2, by = "Species")
combn_pair <- function(data, cols_bind, by = NULL, pairs_n = 2, sep = "-") {
  . <- NULL
  # Validate inputs: check data types and conditions
  if (!inherits(data, c("data.table", "data.frame"))) {
    stop("data must be a data.table or a data.frame")  # Stop if data is neither a data.table nor a data.frame
  }
  data <- data.table::as.data.table(data)  # Convert data to a data.table if it's a data.frame

  if (!is.character(cols_bind)) {
    stop("cols_bind must be a character vector")  # Stop if cols_bind is not a character vector
  }

  if (!is.numeric(pairs_n) || pairs_n < 2 || floor(pairs_n) != pairs_n) {
    stop("pairs_n must be a positive integer greater than or equal to 2")  # Validate pairs_n as a positive integer >= 2
  }

  if (!is.character(sep) || length(sep) != 1) {
    stop("sep must be a single character string")  # Ensure sep is a single character
  }

  if (!is.null(by) && (!is.character(by) || !all(by %in% names(data)))) {
    stop("All elements in 'by' must be valid column names in the data.")  # Validate by elements as column names in data
  }

  # Prepare data for combination operations
  dt <- data.table::copy(data)  # Copy the data to avoid modifying the original
  ncols <- ncol(dt)  # Number of columns in the data table
  col_names <- names(dt)  # Column names of the data table
  cols_n <- length(cols_bind)  # Number of columns to bind
  fixed_names <- names(dt)[!col_names %chin% cols_bind]  # Names of columns not in cols_bind
  data.table::setcolorder(dt, fixed_names)  # Reorder columns to put fixed_names first
  nums_fixed_col <- ncols - length(cols_bind)  # Calculate number of fixed columns

  # Generate combinations of columns and create new combined columns
  cols_pairs <- lapply(as.data.frame(combn(cols_n, pairs_n) + nums_fixed_col), function(x) c(1:nums_fixed_col, x))
  data_pairs <- lapply(cols_pairs, function(x) dt[, .SD, .SDcols = x])
  pairs_name1 <- lapply(as.data.frame(combn(cols_n, pairs_n) + nums_fixed_col), function(x) c(x))
  pairs_name2 <- lapply(pairs_name1, function(x) names(dt[, .SD, .SDcols = x]))
  pairs_name3 <- lapply(pairs_name2, function(x) paste(x, collapse = sep))
  dt_add_pairs <- mapply(cbind, data_pairs, pairs_name3, SIMPLIFY = FALSE)
  dt_named <- lapply(dt_add_pairs, function(x) data.table::setnames(x, c(names(x)[1:nums_fixed_col], paste0("value", seq(1, pairs_n, 1)), "pairs")))
  dt_bind <- data.table::rbindlist(dt_named)

  # Group and nest the data based on 'by' and 'pairs'
  if (!is.null(by)) {
    groupby <- c("pairs", by)  # Grouping columns including pairs and by
    nested_data <- dt_bind[, .(data = list(.SD)), by = groupby]  # Nest data within groups
  } else {
    nested_data <- dt_bind[, .(data = list(.SD)), by = "pairs"]  # Nest data by pairs only
  }

  # Return the nested data table
  return(nested_data)
}
