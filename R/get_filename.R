# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Extract Filenames from File Paths
#'
#' @description
#' Extracts filenames from file paths with options to remove file extensions 
#' and/or directory paths.
#'
#' @param paths A character vector of file paths
#' @param rm_extension Logical. If TRUE, removes file extensions from filenames. 
#'   Defaults to TRUE.
#' @param rm_path Logical. If TRUE, removes directory paths, keeping only the filename. 
#'   Defaults to TRUE.
#'
#' @details
#' The function performs the following operations:
#' \itemize{
#'   \item Validates input paths
#'   \item Handles empty input vectors
#'   \item Optionally removes directory paths using \code{\link[base]{basename}}
#'   \item Optionally removes file extensions using regex substitution
#' }
#'
#' @return A character vector of processed filenames
#'
#' @note
#' - If both \code{rm_extension} and \code{rm_path} are FALSE, 
#'   a warning is issued and the original paths are returned
#' - Supports multiple file paths in the input vector
#'
#' @seealso
#' \code{\link[base]{basename}} for extracting filenames
#'
#' @export
#' @examples
#' xlsx_files <- mintyr_example(mintyr_examples("xlsx_test"))
#' xlsx_files
#' get_filename(xlsx_files) # Keep only file names
#' get_filename(xlsx_files, rm_extension = FALSE) # Keep extension
#' get_filename(xlsx_files, rm_path = FALSE) # Keep path
get_filename <- function(paths, rm_extension = TRUE, rm_path = TRUE) {

  # Input validation
  if (missing(paths)) {
    stop("Parameter 'paths' cannot be empty")
  }

  if (!is.character(paths)) {
    stop("'paths' must be a character vector")
  }

  # Handle empty vector
  if (length(paths) == 0) {
    return(character(0))
  }

  # Warn if both parameters are FALSE
  if (!rm_extension && !rm_path) {
    warning("Setting both rm_extension=FALSE and rm_path=FALSE returns the original paths")
  }

  # Process paths
  result <- if (rm_path) basename(paths) else paths

  # Process extensions
  if (rm_extension) {
    result <- sub("\\.[^.]*$", "", result)
  }

  return(result)
}
