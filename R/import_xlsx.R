# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Import list of xlsx sheets
#' 
#' The `import_xlsx` function reads data from Excel files, optionally from specified sheets, and can either merge data from multiple files or keep them separate.
#' 
#' @param file character vector of file paths. Paths to the Excel files to be imported. These paths must point to existing files.
#' @inheritParams import_csv
#' @param sheet numeric vector or NULL, optional. Specifies the sheets to be read from each file. If NULL, all sheets are read. If numeric, only the specified sheets (by index) are read. Default is NULL.
#' @param ... Additional arguments to be passed to the [readxl::read_excel()] function, such as col_types to specify column data types.
#'
#' @return Depending on the `rbind` parameter:
#' \itemize{
#'   \item If `rbind` is TRUE, returns a single `data.table` combining all files and sheets, with an additional 'excel_name' column indicating the source file.
#'   \item If `rbind` is FALSE, returns a named list of `data.tables`, each representing data from a sheet, named by combining the file and sheet names.
#' }
#' 
#' @importFrom data.table ":="
#' 
#' @export
#' 
#' @note
#' Make sure that the `file` paths provided are valid and exist. The function will stop with an error if any file does not exist or if the sheet indices are out of range.
#' @examples
#' xlsx_files <- mintyr_example(mintyr_examples("xlsx_test"))
#' xlsx_files
#' import_xlsx(xlsx_files)
import_xlsx <- function(file, rbind = TRUE, sheet = NULL, ...) {
  excel_name <- NULL
  # Parameter checks
  if (!is.character(file) || !all(file.exists(file))) {
    stop("file must be a vector of existing file paths.")
  }
  
  if (!is.logical(rbind)) {
    stop("Parameter 'rbind' should be logical (TRUE or FALSE).")
  }
  
  # Reads selected sheets from a single Excel file and converts them into a data.table
  read_selected_sheets <- function(file_path, merge, sheet_indices, ...) {
    all_sheets <- readxl::excel_sheets(file_path)
    # Validate sheet indices
    if (!is.null(sheet_indices)) {
      if (is.numeric(sheet_indices)) {
        if (any(sheet_indices > length(all_sheets)) || any(sheet_indices < 1)) {
          stop("sheet index out of range for file: ", file_path)
        }
      } else {
        stop("sheet parameter must be a numeric vector or NULL.")
      }
    }
    
    selected_sheets <- if (is.null(sheet_indices)) all_sheets else all_sheets[sheet_indices]
    
    sheet_data <- lapply(selected_sheets, function(s) {
      dt <- data.table::as.data.table(readxl::read_excel(file_path, sheet = s, ...))
      if (!merge) {
        return(list(data = dt))  # Return each sheet as an independent list item if not merging
      } else {
        return(dt)
      }
    })
    
    if (merge) {
      names(sheet_data) <- selected_sheets
      data.table::rbindlist(sheet_data, use.names = TRUE, fill = TRUE, idcol = "sheet_name")
    } else {
      names(sheet_data) <- selected_sheets
      return(sheet_data)
    }
  }
  
  # Finding minimum sheet count across all Excel files
  min_sheet_count <- min(sapply(file, function(f) length(readxl::excel_sheets(f))))
  
  # Sheet parameter validation
  if (!is.null(sheet)) {
    if (is.numeric(sheet) && (max(sheet) > min_sheet_count || min(sheet) < 1)) {
      stop("sheet parameter contains indices out of range across files.")
    }
  }
  
  # Applies the modified function across all files
  all_data <- lapply(file, read_selected_sheets, merge = rbind, sheet_indices = sheet, ...)
  
  if (rbind) {
    # If merging, use rbindlist to combine all files' data into one data.table
    combined_data <- data.table::rbindlist(all_data, use.names = TRUE, fill = TRUE, idcol = "excel_name")
    xlsx_sheets_names <- sapply(file, function(x) tools::file_path_sans_ext(basename(x)))
    # Set 'excel_name' column's value to the corresponding file names
    combined_data[, excel_name := rep(xlsx_sheets_names, sapply(all_data, nrow))][]
    return(combined_data)
  } else {
    # If not merging, create a new list to store all sheets' data
    result_list <- list()
    xlsx_sheets_names <- sapply(file, function(x) tools::file_path_sans_ext(basename(x)))
    for (i in seq_along(file)) {
      file_name <- xlsx_sheets_names[i]
      file_data <- all_data[[i]]
      # For each file's sheets, set list item names as "file_name_sheet_name"
      for (sheet_name in names(file_data)) {
        list_name <- paste(file_name, sheet_name, sep = "_")
        result_list[[list_name]] <- file_data[[sheet_name]][["data"]]
      }
    }
    return(result_list)
  }
}
