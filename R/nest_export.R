# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Export Nested Data Frames to Files Based on Grouping Columns
#'
#' The `nest_export` function exports nested data frames or data tables stored within a column of a data table (`nest_dt`) to files. It expands the nested data, groups it by specified columns (`group_cols`), and writes the data to files within directories reflecting the groupings. The files can be saved as tab-separated (`.txt`) or comma-separated (`.csv`) values.
#'
#' @param nest_dt A `data.frame` or `data.table` containing at least one nested column of data frames or data tables. This is the input data from which nested data will be exported.
#' @param group_cols A non-empty character vector specifying the columns in `nest_dt` to use for grouping when exporting. Directories will be created based on combinations of these groupings.
#' @param nest_col A single character string specifying the name of the column in `nest_dt` that contains the nested data frames or data tables to be exported. This name also serves as the base filename for the exported files.
#' @param export_path A single character string specifying the base directory path where the files will be exported. If the directory does not exist, it will be created. Defaults to `tempdir()`.
#' @param file_type A character string specifying the type of file to export: either `"txt"` for tab-separated values or `"csv"` for comma-separated values. Defaults to `"txt"`. Case-insensitive.
#'
#' @return An integer representing the total number of files exported successfully.
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Validates the input parameters, ensuring that `nest_col` and `group_cols` are provided and exist within `nest_dt`. It checks that `file_type` is either `"txt"` or `"csv"`.
#'   \item Identifies the nested column specified by `nest_col` and expands it by unnesting the data frames or data tables it contains.
#'   \item Groups the expanded data by the columns specified in `group_cols`.
#'   \item For each group, constructs a directory path based on the grouping values under `export_path` and writes the data to a file named after `nest_col`, using the specified `file_type`.
#'   \item Utilizes multiple threads when writing files for efficiency, using `data.table::fwrite`.
#' }
#'
#' @import data.table
#' @export
#' 
#' @note
#' \itemize{
#'   \item The `nest_dt` must contain at least one nested column of data frames or data tables.
#'   \item The `group_cols` must be a non-empty character vector corresponding to columns in `nest_dt`.
#'   \item The `nest_col` must be a single character string corresponding to a column name in `nest_dt`.
#'   \item If `export_path` does not exist, the function will create it.
#'   \item The function leverages multi-threading via `data.table::fwrite` for faster file writing.
#'   \item The original `nest_dt` is not modified; a modified copy is used internally.
#'   \item If an error occurs during the export process, the function stops and returns an error message.
#' }
#' @examples
#' # Data Nesting Operation
#' dt_nest <- w2l_nest(data = iris, cols2l = 1:2, by = "Species")
#' # Export Nested Data
#' nest_export(nest_dt = dt_nest, nest_col = "data",
#'             group_cols = c("name", "Species"))
#' # Check Export Results
#' list.files(path = tempdir(), pattern = "txt", recursive = TRUE)
nest_export <- function(nest_dt, group_cols = NULL, nest_col = NULL, export_path = tempdir(), file_type = "txt") {
  # Validate that nest_col is provided
  # Ensures that the nested column parameter is not null
  # Throws an error if no nested column is specified
  if (is.null(nest_col)) {
    stop("nest_col must be specified")
  }

  # Use nest_col as the base filename for exported files
  # This allows the nested column name to directly determine the output file name
  basename <- nest_col

  # Validate that input data table is not empty
  if (nrow(nest_dt) == 0) {
    stop("The input nest_dt cannot be empty")
  }

  # Validate file type
  file_type <- tolower(file_type)
  if (!(file_type %in% c("txt", "csv"))) {
    stop("file_type must be either 'txt' or 'csv'")
  }

  # Identify columns containing nested data frames or data tables
  nested_cols <- names(nest_dt)[sapply(nest_dt, function(x) {
    # Check if the column is a list and all elements are data frames or data tables
    is.list(x) && all(sapply(x, function(y) {
      inherits(y, c("data.frame", "data.table"))
    }))
  })]

  # Ensure at least one nested column exists
  if (length(nested_cols) == 0) {
    stop("The input nest_dt must contain at least one nested column of data.frames or data.tables")
  }

  # Use the first nested column if no specific column is specified
  if (is.null(nest_col)) {
    nest_col <- nested_cols[1]
    message("Using first nested column: ", nest_col)
  }

  # Validate group columns
  # Check that group columns are specified and not empty
  if (is.null(group_cols) || length(group_cols) == 0) {
    stop("group_cols must be a non-empty character vector")
  }

  # Ensure group columns are character type
  if (!is.character(group_cols)) {
    stop("group_cols must be a character vector")
  }

  # Validate nest column
  # Ensure nest column is a single character string
  if (!is.character(nest_col) || length(nest_col) != 1) {
    stop("nest_col must be a single character string")
  }

  # Validate export path
  # Ensure export path is a single character string
  if (!is.character(export_path) || length(export_path) != 1) {
    stop("export_path must be a single character string")
  }

  # Validate basename
  if (!is.character(basename) || length(basename) != 1) {
    stop("basename must be a single character string")
  }

  # Check if all specified columns exist in the input data table
  missing_cols <- setdiff(c(group_cols, nest_col), names(nest_dt))
  if (length(missing_cols) > 0) {
    stop("The following columns are missing: ",
         paste(missing_cols, collapse = ", "))
  }

  # Remove any existing key to ensure consistent processing
  setkey(nest_dt, NULL)

  # Create export directory if it doesn't exist
  dir.create(export_path, showWarnings = FALSE, recursive = TRUE)

  # Main export process with error handling
  tryCatch({
    # Expand nested data by unnesting the specified column
    expanded_dt <- nest_dt[, {
      # Process each nested element
      processed_nests <- lapply(get(nest_col), function(x) {
        # Convert to data.table if not already
        x_dt <- if (!is.data.table(x)) as.data.table(x) else x

        # Set row names to ensure compatibility
        setattr(x_dt, "row.names", .set_row_names(nrow(x_dt)))
        x_dt
      })

      # Combine processed nested data
      data.table::rbindlist(processed_nests)
    }, by = group_cols]

    # Create a copy of expanded data to avoid modifications
    expanded_dt <- copy(expanded_dt)

    # Generate unique directory paths for each group combination
    unique_paths <- unique(expanded_dt[, do.call(file.path,
                                                 c(list(export_path),
                                                   lapply(group_cols, function(col) get(col))))])

    # Create directories for each unique group combination
    lapply(unique_paths, function(path) {
      dir.create(path, showWarnings = FALSE, recursive = TRUE)
    })

    # Initialize file count tracker
    file_count <- 0L

    # Export data for each group combination
    expanded_dt[, {
      # Construct directory path based on group columns
      dir_path <- do.call(file.path,
                          c(list(export_path),
                            lapply(group_cols, function(col) get(col))))

      # Determine separator based on file type
      sep <- if (file_type == "txt") "\t" else ","

      # Construct full filename
      filename <- paste0(basename, ".", file_type)

      # Write data to file
      fwrite(.SD,
             file = file.path(dir_path, filename),
             sep = sep,
             nThread = parallel::detectCores() - 1, # Use multiple threads for faster writing
             buffMB = 32) # Set buffer size for efficient writing

      # Increment file count
      file_count <<- file_count + 1L

      # Return NULL to avoid unnecessary data storage
      NULL
    }, by = group_cols]

    # Return total number of files exported
    return(file_count)
  }, error = function(e) {
    # Catch and report any errors during export process
    stop("Failed to export nested data: ", e$message)
  })
}
