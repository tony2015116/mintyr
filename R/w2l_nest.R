# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Reshape Wide Data to Long and Nest by Specified Columns
#' 
#' The `w2l_nest` function reshapes wide-format data to long-format and nests it by specified columns.
#' It is designed to handle both data.frame and data.table objects and provides options for grouping the data.
#' 
#' @param data data.frame or data.table. The input data in wide format.
#' @param cols2l numeric or character vector. Specifies the columns to reshape from wide to long format. Can be either numeric indices or column names.
#' @param by character vector, optional. Specifies the columns to group by. Default is NULL.
#'
#' @return data.table. A data.table with nested data in long format, grouped by specified columns if provided.
#' \itemize{
#'   \item If `by` is NULL, returns a data.table nested by 'name'.
#'   \item If `by` is specified, returns a data.table nested by 'name' and the grouping variables.
#' }
#' 
#' @import data.table
#' 
#' @export
#' 
#' @note
#' \itemize{
#'   \item The `cols2l` parameter should be either numeric indices or a character vector of column names.
#'   \item Ensure all grouping variables specified in `by` are present in the data.
#'   \item The function converts `data.frame` to `data.table` if necessary.
#' }
#' @examples
#' w2l_nest(data = iris, cols2l = 1:4)
#' w2l_nest(data = iris, cols2l = c("Sepal.Length", "Sepal.Width", "Petal.Length"), by = "Species")
w2l_nest <- function(data, cols2l, by=NULL) {
  . <- name <- NULL
  # Ensure the data is a data.table object
  if (is.data.frame(data)) {
    data <- data.table::as.data.table(data)  # Convert data.frame to data.table if necessary
  } else if (!data.table::is.data.table(data)) {
    stop("Data must be either a data.frame or a data.table.")  # Stop if data is not a data.table or data.frame
  }

  # Process grouping variables
  if (!is.null(by) && !all(by %in% names(data))) {
    stop("All grouping variables must be column names in the data: ", paste(by[!by %in% names(data)], collapse=", "))
  }  # Check if all specified grouping variables are in the data, stop with message if not

  # Check the validity of cols2l based on its type
  if (is.numeric(cols2l)) {
    if (any(length(cols2l) < 1 | length(cols2l) > ncol(data))) {
      stop("Numeric indices in cols2l are out of bounds.")  # Stop if numeric indices are out of bounds
    }
  } else if (is.character(cols2l)) {
    if (!all(cols2l %in% names(data))) {
      stop("Some columns specified in cols2l are not present in the data.")  # Stop if some specified column names do not exist
    }
  } else {
    stop("cols2l should be either numeric indices or character vector of column names.")  # Ensure cols2l is either numeric or character
  }

  # Melt the data with or without grouping variables
  melted_data <- data.table::melt(data, measure.vars = cols2l, variable.name = "name", value.name = "value")  # Melt the data using specified cols2l

  if (is.null(by) || length(by) == 0) {
    # No grouping
    return(melted_data[, .(data = list(.SD)), by = name])  # Return melted data without grouping, nested by 'name'
  } else {
    # With grouping
    groupby <- c("name", by)  # Combine 'name' and 'by' for grouping
    return(melted_data[, .(data = list(.SD)), by = groupby])  # Return melted data with grouping, nested by 'name' and grouping variables
  }
}
