---
title: "flat_teaching.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- 
Run this 'development' chunk

Store every call to library() that you need to run chunks line by line, as in a classical Rmd for analysis
-->

```{r development, include=FALSE}
library(testthat)
library(roxygen2)
```

<!--
# Description of your package

This will fill the description of your package.
Fill and run the content of this chunk, before anything else. 

Note: when you will use other flat templates, this part will be in a separate file. Do not be surprised!
--> 

```{r description, eval=FALSE}
# Describe your package
fusen::fill_description(
  pkg = here::here(),
  fields = list(
    Title = "Tools commonly used in personal data processing work",
    Description = "A Set of tools to understand packages structure. Use Rmarkdown First method to build a package from a defined template. Start your package with documentation. Everything can be set from a Rmarkdown file in your project.",
    `Authors@R` = c(
      person("Guo Meng", email = "tony2015116@163.com", role = c("aut", "cre")),
      person(given = "Guo Meng", role = "cph")
    )
  ), overwrite = T
)
# Define License with use_*_license()
usethis::use_mit_license("Guo Meng")
```


# convert_nested
    
```{r function-convert_nested}
#' Convert Nested Columns Between Data Frame and Data Table
#'
#' @description
#' This function converts a data frame or data table, transforming nested columns 
#' to either data frame or data table format while preserving the original data structure.
#'
#' @param data A data frame or data table containing nested columns
#' @param to A character string specifying the target format. 
#'   Options are "df" (data frame) or "dt" (data table). Defaults to "df".
#' @param nested_cols A character vector of column names containing nested data. 
#'   If NULL, the function automatically detects list columns.
#'
#' @details
#' The function performs the following operations:
#' \itemize{
#'   \item Automatically detects nested columns if not explicitly specified
#'   \item Converts the entire data structure to the target format (data frame or data table)
#'   \item Converts nested columns within the specified columns to the target format
#'   \item Creates a copy of the input data to avoid modifying the original
#' }
#'
#' @return A data frame or data table with nested columns converted to the specified format
#'
#' @note
#' - The function preserves the original data structure
#' - Nested columns are converted individually
#' - Automatic detection of nested columns is based on list-type columns
#' 
#' @importFrom data.table as.data.table copy
#' @export
convert_nested <- function(data, to = c("df", "dt"), nested_cols = NULL) {
  to <- match.arg(to)

  # Automatically detect nested columns (list columns) if not specified
  if (is.null(nested_cols)) {
    nested_cols <- names(data)[sapply(data, is.list)]
  }

  if (to == "df") {
    # If data is data.table, convert to data.frame and copy to avoid modifying original data
    if (inherits(data, "data.table")) {
      data <- as.data.frame(copy(data))
    } else if (!inherits(data, "data.frame")) {
      data <- as.data.frame(data)
    }
    # Convert each element of nested columns to data.frame
    for (col in nested_cols) {
      data[[col]] <- lapply(data[[col]], function(x) {
        if (inherits(x, "data.table")) {
          as.data.frame(copy(x))
        } else if (!inherits(x, "data.frame")) {
          as.data.frame(x)
        } else {
          x
        }
      })
    }
  } else if (to == "dt") {
    # If data is not data.table, convert to data.table and copy to avoid modifying original data
    if (!inherits(data, "data.table")) {
      data <- as.data.table(copy(data))
    }
    # Convert each element of nested columns to data.table
    for (col in nested_cols) {
      data[[col]] <- lapply(data[[col]], function(x) {
        if (!inherits(x, "data.table")) {
          as.data.table(copy(x))
        } else {
          x
        }
      })
    }
  }

  return(data)
}
```
  
```{r example-convert_nested}
# Convert a data frame with nested columns to data table
df_nest1 <- iris |> 
  dplyr::group_nest(Species)
df_nest2 <- iris |>
  dplyr::group_nest(Species) |>
  dplyr::mutate(data2 = purrr::map(data, dplyr::mutate, c=2))
# Convert a data table with specific nested columns to data frame
convert_nested(df_nest1, to = "dt", nested_cols = c("data"))
convert_nested(df_nest2, to = "dt", nested_cols = c("data", "data2"))
# Convert a data table with nested columns to data frame
dt_nest <- mintyr::w2l_nest(data = iris, cols2l = 1:2, by = "Species")
convert_nested(dt_nest, to = "dt", nested_cols = c("data"))
```
  
  
# get_path_segment
    
```{r function-get_path_segment}
#' Extract Specific Segments from File Paths
#'
#' The `get_path_segment` function extracts specific segments from file paths provided as character strings. Segments can be extracted from either the beginning or the end of the path, depending on the value of `n`.
#'
#' @param paths A non-empty character vector containing file paths, where each path is a string with segments separated by forward slashes (`/`). This parameter cannot be empty.
#' @param n An integer specifying which segment to extract from each path. If `n` is positive, the function extracts the `n`-th segment from the beginning of the path. If `n` is negative, the function extracts the `n`-th segment from the end of the path. `n` cannot be zero.
#'
#' @return A character vector of the extracted segments. If a path does not have the requested segment, `NA_character_` is returned for that path.
#'
#' @details
#' The function operates as follows:
#' \enumerate{
#'   \item Validates that `paths` is a non-empty character vector and that `n` is a non-zero numeric value.
#'   \item Splits each path in `paths` into segments based on the forward slash (`/`) delimiter.
#'   \item Extracts the specified segment from each set of path segments:
#'   \itemize{
#'     \item If `n > 0`, the function extracts the `n`-th segment counting from the start of the path.
#'     \item If `n < 0`, the function extracts the `n`-th segment counting from the end of the path.
#'   }
#'   \item If a path does not contain the specified segment, `NA_character_` is returned for that path.
#' }
#'
#' @note
#' - The `paths` parameter must be a non-empty character vector.
#' - The `n` parameter must be a non-zero numeric value.
#' - If `n` is zero, the function will raise an error.
#' - The function handles empty strings and paths with consecutive slashes appropriately.
#'  
#' @export
get_path_segment <- function(paths, n = 1) {
  # Check if paths parameter is provided
  if (missing(paths)) stop("Parameter 'paths' cannot be empty")

  # Validate paths is a character vector
  if (!is.character(paths)) stop("'paths' must be character")

  # Return empty character vector if paths is empty
  if (length(paths) == 0) return(character(0))

  # Validate n is numeric
  if (!is.numeric(n)) stop("'n' must be numeric")

  # Prevent zero index
  if (n == 0) stop("'n' cannot be 0")

  # Split paths into segments
  segments <- strsplit(paths, "/")

  # Extract specific path segments
  result <- sapply(segments, function(x) {
    if (n > 0) {
      # Positive index: count from the beginning
      # Return segment if index exists, otherwise return NA
      if (length(x) >= n) x[n] else NA_character_
    } else {
      # Negative index: count from the end
      # Convert negative index to positive position
      pos <- length(x) + n + 1

      # Return segment if position is valid, otherwise return NA
      if (pos > 0 && pos <= length(x)) x[pos] else NA_character_
    }
  })

  return(result)
}
```
  
```{r example-get_path_segment}
# Example usage demonstrations
paths <- c("/home/user/documents", "/var/log/system", "/usr/local/bin")
# Positive index example
get_path_segment(paths, 2)
# Negative index example
get_path_segment(paths, -2)
```
  

# nest_export
    
```{r function-nest_export}
#' Export Nested Data Frames to Files Based on Grouping Columns
#'
#' The `nest_export` function exports nested data frames or data tables stored within a column of a data table (`nest_dt`) to files. It expands the nested data, groups it by specified columns (`group_cols`), and writes the data to files within directories reflecting the groupings. The files can be saved as tab-separated (`.txt`) or comma-separated (`.csv`) values.
#'
#' @param nest_dt A `data.frame` or `data.table` containing at least one nested column of data frames or data tables. This is the input data from which nested data will be exported.
#' @param group_cols A non-empty character vector specifying the columns in `nest_dt` to use for grouping when exporting. Directories will be created based on combinations of these groupings.
#' @param nest_col A single character string specifying the name of the column in `nest_dt` that contains the nested data frames or data tables to be exported. This name also serves as the base filename for the exported files.
#' @param export_path A single character string specifying the base directory path where the files will be exported. If the directory does not exist, it will be created. Defaults to `tempdir()`.
#' @param file_type A character string specifying the type of file to export: either `"txt"` for tab-separated values or `"csv"` for comma-separated values. Defaults to `"txt"`. Case-insensitive.
#'
#' @return An integer representing the total number of files exported successfully.
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Validates the input parameters, ensuring that `nest_col` and `group_cols` are provided and exist within `nest_dt`. It checks that `file_type` is either `"txt"` or `"csv"`.
#'   \item Identifies the nested column specified by `nest_col` and expands it by unnesting the data frames or data tables it contains.
#'   \item Groups the expanded data by the columns specified in `group_cols`.
#'   \item For each group, constructs a directory path based on the grouping values under `export_path` and writes the data to a file named after `nest_col`, using the specified `file_type`.
#'   \item Utilizes multiple threads when writing files for efficiency, using `data.table::fwrite`.
#' }
#'
#' @import data.table
#' @export
#' 
#' @note
#' \itemize{
#'   \item The `nest_dt` must contain at least one nested column of data frames or data tables.
#'   \item The `group_cols` must be a non-empty character vector corresponding to columns in `nest_dt`.
#'   \item The `nest_col` must be a single character string corresponding to a column name in `nest_dt`.
#'   \item If `export_path` does not exist, the function will create it.
#'   \item The function leverages multi-threading via `data.table::fwrite` for faster file writing.
#'   \item The original `nest_dt` is not modified; a modified copy is used internally.
#'   \item If an error occurs during the export process, the function stops and returns an error message.
#' }
nest_export <- function(nest_dt, group_cols = NULL, nest_col = NULL, export_path = tempdir(), file_type = "txt") {
  # Validate that nest_col is provided
  # Ensures that the nested column parameter is not null
  # Throws an error if no nested column is specified
  if (is.null(nest_col)) {
    stop("nest_col must be specified")
  }

  # Use nest_col as the base filename for exported files
  # This allows the nested column name to directly determine the output file name
  basename <- nest_col

  # Validate that input data table is not empty
  if (nrow(nest_dt) == 0) {
    stop("The input nest_dt cannot be empty")
  }

  # Validate file type
  file_type <- tolower(file_type)
  if (!(file_type %in% c("txt", "csv"))) {
    stop("file_type must be either 'txt' or 'csv'")
  }

  # Identify columns containing nested data frames or data tables
  nested_cols <- names(nest_dt)[sapply(nest_dt, function(x) {
    # Check if the column is a list and all elements are data frames or data tables
    is.list(x) && all(sapply(x, function(y) {
      inherits(y, c("data.frame", "data.table"))
    }))
  })]

  # Ensure at least one nested column exists
  if (length(nested_cols) == 0) {
    stop("The input nest_dt must contain at least one nested column of data.frames or data.tables")
  }

  # Use the first nested column if no specific column is specified
  if (is.null(nest_col)) {
    nest_col <- nested_cols[1]
    message("Using first nested column: ", nest_col)
  }

  # Validate group columns
  # Check that group columns are specified and not empty
  if (is.null(group_cols) || length(group_cols) == 0) {
    stop("group_cols must be a non-empty character vector")
  }

  # Ensure group columns are character type
  if (!is.character(group_cols)) {
    stop("group_cols must be a character vector")
  }

  # Validate nest column
  # Ensure nest column is a single character string
  if (!is.character(nest_col) || length(nest_col) != 1) {
    stop("nest_col must be a single character string")
  }

  # Validate export path
  # Ensure export path is a single character string
  if (!is.character(export_path) || length(export_path) != 1) {
    stop("export_path must be a single character string")
  }

  # Validate basename
  if (!is.character(basename) || length(basename) != 1) {
    stop("basename must be a single character string")
  }

  # Check if all specified columns exist in the input data table
  missing_cols <- setdiff(c(group_cols, nest_col), names(nest_dt))
  if (length(missing_cols) > 0) {
    stop("The following columns are missing: ",
         paste(missing_cols, collapse = ", "))
  }

  # Remove any existing key to ensure consistent processing
  setkey(nest_dt, NULL)

  # Create export directory if it doesn't exist
  dir.create(export_path, showWarnings = FALSE, recursive = TRUE)

  # Main export process with error handling
  tryCatch({
    # Expand nested data by unnesting the specified column
    expanded_dt <- nest_dt[, {
      # Process each nested element
      processed_nests <- lapply(get(nest_col), function(x) {
        # Convert to data.table if not already
        x_dt <- if (!is.data.table(x)) as.data.table(x) else x

        # Set row names to ensure compatibility
        setattr(x_dt, "row.names", .set_row_names(nrow(x_dt)))
        x_dt
      })

      # Combine processed nested data
      data.table::rbindlist(processed_nests)
    }, by = group_cols]

    # Create a copy of expanded data to avoid modifications
    expanded_dt <- copy(expanded_dt)

    # Generate unique directory paths for each group combination
    unique_paths <- unique(expanded_dt[, do.call(file.path,
                                                 c(list(export_path),
                                                   lapply(group_cols, function(col) get(col))))])

    # Create directories for each unique group combination
    lapply(unique_paths, function(path) {
      dir.create(path, showWarnings = FALSE, recursive = TRUE)
    })

    # Initialize file count tracker
    file_count <- 0L

    # Export data for each group combination
    expanded_dt[, {
      # Construct directory path based on group columns
      dir_path <- do.call(file.path,
                          c(list(export_path),
                            lapply(group_cols, function(col) get(col))))

      # Determine separator based on file type
      sep <- if (file_type == "txt") "\t" else ","

      # Construct full filename
      filename <- paste0(basename, ".", file_type)

      # Write data to file
      fwrite(.SD,
             file = file.path(dir_path, filename),
             sep = sep,
             nThread = parallel::detectCores() - 1, # Use multiple threads for faster writing
             buffMB = 32) # Set buffer size for efficient writing

      # Increment file count
      file_count <<- file_count + 1L

      # Return NULL to avoid unnecessary data storage
      NULL
    }, by = group_cols]

    # Return total number of files exported
    return(file_count)
  }, error = function(e) {
    # Catch and report any errors during export process
    stop("Failed to export nested data: ", e$message)
  })
}
```
  
```{r example-nest_export}
# Data Nesting Operation
dt_nest <- w2l_nest(data = iris, cols2l = 1:2, by = "Species")
# Export Nested Data
nest_export(nest_dt = dt_nest, nest_col = "data",
            group_cols = c("name", "Species"))
# Check Export Results
list.files(path = tempdir(), pattern = "txt", recursive = TRUE)
```



# format_digits
    
```{r function-format_digits}
#' Format Numeric Columns with Specified Digits
#'
#' The `format_digits` function formats numeric columns in a data frame or data table by rounding numbers to a specified number of decimal places and converting them to character strings. It can optionally format the numbers as percentages.
#'
#' @param data A `data.frame` or `data.table`. The input data containing numeric columns to format.
#' @param cols An optional numeric or character vector specifying the columns to format. If `NULL` (default), all numeric columns are formatted.
#' @param digits A non-negative integer specifying the number of decimal places to use. Defaults to `2`.
#' @param percentage A logical value indicating whether to format the numbers as percentages. If `TRUE`, the numbers are multiplied by 100 and a percent sign (`%`) is appended. Defaults to `FALSE`.
#'
#' @return A `data.table` with the specified numeric columns formatted as character strings with the specified number of decimal places. If `percentage = TRUE`, the numbers are shown as percentages.
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Validates the input parameters, ensuring that `data` is a `data.frame` or `data.table`, `cols` (if provided) are valid column names or indices, and `digits` is a non-negative integer.
#'   \item Converts `data` to a `data.table` if it is not already one.
#'   \item Creates a formatting function based on the `digits` and `percentage` parameters:
#'   \itemize{
#'     \item If `percentage = FALSE`, numbers are rounded to `digits` decimal places.
#'     \item If `percentage = TRUE`, numbers are multiplied by 100, rounded to `digits` decimal places, and a percent sign (`%`) is appended.
#'   }
#'   \item Applies the formatting function to the specified columns:
#'   \itemize{
#'     \item If `cols` is `NULL`, the function formats all numeric columns in `data`.
#'     \item If `cols` is specified, only those columns are formatted.
#'   }
#'   \item Returns a new `data.table` with the formatted columns.
#' }
#'
#' @import data.table
#' @export
#'
#' @note
#' \itemize{
#'   \item The input `data` must be a `data.frame` or `data.table`.
#'   \item If `cols` is specified, it must be a vector of valid column names or indices present in `data`.
#'   \item The `digits` parameter must be a single non-negative integer.
#'   \item The original `data` is not modified; a modified copy is returned.
#' }


format_digits <- function(data, cols = NULL, digits = 2, percentage = FALSE) {
  # Parameter checks
  if (!is.data.frame(data)) {
    stop("Input data must be a data.frame or data.table object")
  }

  # Convert to data.table if it's a data.frame
  if (!is.data.table(data)) {
    data <- as.data.table(data)
  }

  # Check cols parameter
  if (!is.null(cols)) {
    if (!is.numeric(cols) && !is.character(cols)) {
      stop("'cols' must be numeric or character vector")
    }

    if (length(cols) == 0) {
      stop("When specified, 'cols' cannot be empty")
    }

    if (is.numeric(cols)) {
      if (any(cols < 1) || any(cols > ncol(data))) {
        stop("Numeric column indices must be between 1 and ", ncol(data))
      }
      cols <- names(data)[cols]
    }

    if (!all(cols %in% names(data))) {
      invalid_cols <- cols[!cols %in% names(data)]
      stop("Following columns do not exist in the data: ",
           paste(invalid_cols, collapse = ", "))
    }
  }

  # Check digits parameter
  if (!is.numeric(digits) ||
      length(digits) != 1 ||
      digits < 0 ||
      digits != round(digits)) {
    stop("'digits' must be a single non-negative integer")
  }

  # Create format string based on percentage parameter
  fmt <- if(percentage) {
    function(x) sprintf(paste0("%.", digits, "f%%"), round(as.numeric(x) * 100, digits))
  } else {
    function(x) sprintf(paste0("%.", digits, "f"), as.numeric(x))
  }

  # Create a copy of the data to modify
  result <- copy(data)

  # Process all numeric columns if cols is NULL
  if (is.null(cols)) {
    result[, names(.SD) := lapply(.SD, fmt), .SDcols = is.numeric][]
  } else {
    # Process specified columns
    result[, (cols) := lapply(.SD, fmt), .SDcols = cols][]
  }

  return(result)
}
```
  
```{r example-format_digits}
# Create example data
dt <- data.table::data.table(
  a = c(0.1234, 0.5678),
  b = c(0.2345, 0.6789),
  c = c("text1", "text2")
)
dt
# Format without percentage
format_digits(dt, cols = c("a", "b"))
# Format with percentage
format_digits(dt, cols = c("a"), percentage = TRUE)
```
  


# mintyr_example
    
```{r function-mintyr_example}
#' Get path to mintyr examples
#' 
#' mintyr comes bundled with a number of sample files in
#' its 'inst/extdata' directory. Use `vroom_example()` to retrieve the path to one
#' example.
#' 
#' @param path Name of file.
#' @seealso [mintyr::mintyr_examples()]
#' @export
mintyr_example <- function (path) {
  system.file("extdata", path, package = "mintyr", mustWork = TRUE)
}
```
  
```{r example-mintyr_example}
mintyr_example("csv_test1.csv")
```
  
# mintyr_examples
    
```{r function-mintyr_examples}
#' Get path to one example
#' 
#' vroom comes bundled with a number of sample files in
#' its 'inst/extdata' directory. Use `vroom_examples()` to list all the
#' available examples.
#' 
#' @param pattern A regular expression of filenames to match. If `NULL`, all available files are returned.
#' @seealso [mintyr::mintyr_example()]
#' @export
mintyr_examples <- function (pattern = NULL) {
  list.files(system.file("extdata", package = "mintyr"), pattern = pattern)
}
```
  
```{r example-mintyr_examples}
mintyr_examples()
```
  
  
# import_xlsx
    
```{r function-import_xlsx}
#' Import Data from Excel Files
#' 
#' The `import_xlsx` function provides a flexible way to import data from one or multiple
#' Excel files, with options to specify sheets and combine or separate the imported data.
#' It handles multiple files and sheets, with automatic source tracking.
#' 
#' @param file A character vector of file paths. The Excel files to be imported.
#'   All paths must point to existing .xlsx or .xls files.
#' @param rbind A logical value. If TRUE and multiple files/sheets are provided,
#'   combines all data into a single data.table. If FALSE, returns a list of
#'   data.tables. Default is TRUE.
#' @param sheet A numeric vector or NULL. Specifies which sheets to read from each file:
#'   \itemize{
#'     \item If NULL (default), reads all sheets.
#'     \item If numeric, reads only the specified sheet indices.
#'   }
#' @param ... Additional arguments passed to [readxl::read_excel()], such as
#'   col_types, skip, or na.
#'
#' @seealso [readxl::read_excel()]
#'
#' @return Depends on the `rbind` parameter:
#' \itemize{
#'   \item If rbind = TRUE: A single data.table containing all imported data with
#'     two additional columns:
#'     \itemize{
#'       \item excel_name: The source file name (without extension)
#'       \item sheet_name: The source sheet name
#'     }
#'   \item If rbind = FALSE: A named list of data.tables, where each element is named
#'     as "filename_sheetname" and contains the data from that specific sheet.
#' }
#' 
#' @details
#' The function provides a comprehensive solution for importing Excel data with the
#' following features:
#' \itemize{
#'   \item Supports multiple files and sheets
#'   \item Automatic source tracking for files and sheets
#'   \item Flexible combining options
#'   \item Handles missing columns across sheets when combining
#'   \item Preserves original data types through readxl
#' }
#' 
#' @importFrom data.table ":="
#' 
#' @export
#' 
#' @note
#' \itemize{
#'   \item All specified files must exist and be accessible Excel files
#'   \item Sheet indices must be valid across all input files
#'   \item When rbind = TRUE, the function assumes compatible data structures
#'     across sheets and files
#'   \item Missing columns across sheets are filled with NA when combining
#'   \item File names in source tracking columns have their extensions removed
#' }
import_xlsx <- function(file, rbind = TRUE, sheet = NULL, ...) {
  excel_name <- NULL
  # Parameter checks
  if (!is.character(file) || !all(file.exists(file))) {
    stop("file must be a vector of existing file paths.")
  }

  if (!is.logical(rbind)) {
    stop("Parameter 'rbind' should be logical (TRUE or FALSE).")
  }

  # Function to remove file extension
  remove_extension <- function(filename) {
    sub("\\.[^.]*$", "", basename(filename))
  }

  # Reads selected sheets from a single Excel file and converts them into a data.table
  read_selected_sheets <- function(file_path, merge, sheet_indices, ...) {
    all_sheets <- readxl::excel_sheets(file_path)
    # Validate sheet indices
    if (!is.null(sheet_indices)) {
      if (is.numeric(sheet_indices)) {
        if (any(sheet_indices > length(all_sheets)) || any(sheet_indices < 1)) {
          stop("sheet index out of range for file: ", file_path)
        }
      } else {
        stop("sheet parameter must be a numeric vector or NULL.")
      }
    }

    selected_sheets <- if (is.null(sheet_indices)) all_sheets else all_sheets[sheet_indices]

    sheet_data <- lapply(selected_sheets, function(s) {
      dt <- data.table::as.data.table(readxl::read_excel(file_path, sheet = s, ...))
      if (!merge) {
        return(list(data = dt))  # Return each sheet as an independent list item if not merging
      } else {
        return(dt)
      }
    })

    if (merge) {
      names(sheet_data) <- selected_sheets
      data.table::rbindlist(sheet_data, use.names = TRUE, fill = TRUE, idcol = "sheet_name")
    } else {
      names(sheet_data) <- selected_sheets
      return(sheet_data)
    }
  }

  # Finding minimum sheet count across all Excel files
  min_sheet_count <- min(sapply(file, function(f) length(readxl::excel_sheets(f))))

  # Sheet parameter validation
  if (!is.null(sheet)) {
    if (is.numeric(sheet) && (max(sheet) > min_sheet_count || min(sheet) < 1)) {
      stop("sheet parameter contains indices out of range across files.")
    }
  }

  # Applies the modified function across all files
  all_data <- lapply(file, read_selected_sheets, merge = rbind, sheet_indices = sheet, ...)

  if (rbind) {
    # If merging, use rbindlist to combine all files' data into one data.table
    combined_data <- data.table::rbindlist(all_data, use.names = TRUE, fill = TRUE, idcol = "excel_name")
    xlsx_sheets_names <- sapply(file, remove_extension)  # 使用remove_extension替代tools::file_path_sans_ext
    # Set 'excel_name' column's value to the corresponding file names
    combined_data[, excel_name := rep(xlsx_sheets_names, sapply(all_data, nrow))][]
    return(combined_data)
  } else {
    # If not merging, create a new list to store all sheets' data
    result_list <- list()
    xlsx_sheets_names <- sapply(file, remove_extension)  # 使用remove_extension替代tools::file_path_sans_ext
    for (i in seq_along(file)) {
      file_name <- xlsx_sheets_names[i]
      file_data <- all_data[[i]]
      # For each file's sheets, set list item names as "file_name_sheet_name"
      for (sheet_name in names(file_data)) {
        list_name <- paste(file_name, sheet_name, sep = "_")
        result_list[[list_name]] <- file_data[[sheet_name]][["data"]]
      }
    }
    return(result_list)
  }
}
```
  
```{r example-import_xlsx}
xlsx_files <- mintyr_example(mintyr_examples("xlsx_test"))
xlsx_files
import_xlsx(xlsx_files)
```
  

  
# import_csv

This is the first tool of our wonderful package. 
You can add `1` to any `value` using function `add_one()`.

<!-- 
This first section shows:

- the three parts necessary for a package: 'function', 'examples' and 'tests'.  
  + Note that the three following chunks have names accordingly.

-->

```{r function-import_csv}
#' Import CSV Files with Flexible Reading Options
#' 
#' The `import_csv` function provides a flexible way to import one or multiple CSV files
#' using either data.table or arrow package. It supports combining multiple files and
#' adding source file labels.
#' 
#' @param file A character vector of file paths. The CSV files to be imported.
#' @param package A character string, either "data.table" or "arrow". Specifies which package
#'   to use for reading CSV files. Default is "data.table".
#' @param rbind A logical value. If TRUE and multiple files are provided, combines all files
#'   into a single data object. If FALSE, returns a list of data objects. Default is TRUE.
#' @param rbind_label A character string or NULL. When rbinding multiple files, specifies
#'   the column name for the file source label. If NULL, no label column is added.
#'   Default is "_file".
#' @param ... Additional arguments passed to the underlying read functions
#'   (data.table::fread or arrow::read_csv_arrow).
#'
#' @seealso [data.table::fread()] 
#' @seealso [arrow::read_csv_arrow()]
#'
#' @return Depending on the parameters:
#' \itemize{
#'   \item If rbind = TRUE: A single data.table or arrow table containing all imported data.
#'   \item If rbind = FALSE: A named list of data.table or arrow table objects, with names
#'     derived from the input file names (without extensions).
#' }
#' 
#' @details
#' The function provides a unified interface for reading CSV files using either data.table
#' or arrow package. When reading multiple files, it can either combine them into a single
#' data object or return them as a list. File source tracking is supported through the
#' rbind_label parameter.
#' 
#' @import data.table
#' @import arrow
#' 
#' @export
#' 
#' @note
#' \itemize{
#'   \item All specified files must exist and be accessible.
#'   \item When rbind = TRUE and multiple files are imported, the function assumes compatible
#'     column structures across files.
#'   \item File names in the source label column (if added) will have their extensions removed.
#'   \item The function uses data.table::rbindlist for combining multiple files, which
#'     automatically handles missing columns across files.
#' }

import_csv <- function (file, package = "data.table", rbind = TRUE, rbind_label = "_file", ...) {
  # Validations
  if (!is.character(file) || !all(file.exists(file))) {
    stop("file must be a vector of existing file paths.")
  }

  if (!package %in% c("data.table", "arrow")) {
    stop("package must be one of 'data.table', 'arrow'.")
  }

  # Function to remove file extension
  remove_extension <- function(filename) {
    sub("\\.[^.]*$", "", basename(filename))
  }

  # Read Functionality with naming
  read_files <- function(read_function) {
    file_data <- lapply(file, function(file_path) {
      df <- read_function(file_path, ...)
      if (!is.null(rbind_label) && rbind && length(file) > 1) {
        # Add a column with the label indicating the file origin, without extension
        df <- cbind(stats::setNames(data.frame(remove_extension(file_path)), rbind_label), df)
      }
      return(df)
    })

    if (rbind && length(file) > 1) {
      # Combine all data into a single data table/data frame
      return(data.table::rbindlist(file_data, use.names = TRUE, fill = TRUE))
    } else {
      # When rbind is FALSE, name the list elements with file names
      names(file_data) <- remove_extension(file)
      return(file_data)
    }
  }

  # Package specific operations
  if (package == "data.table") {
    return(read_files(data.table::fread))
  } else if (package == "arrow") {
    return(read_files(arrow::read_csv_arrow))
  }
}
```

<!--
Here is an example on how to use the function.
This should be a reproducible and working example
-->

```{r examples-import_csv}
csv_files <- mintyr_example(mintyr_examples("csv_test"))
csv_files
import_csv(csv_files)
```


# get_filename
    
```{r function-get_filename}
#' Extract Filenames from File Paths
#'
#' @description
#' Extracts filenames from file paths with options to remove file extensions 
#' and/or directory paths.
#'
#' @param paths A character vector of file paths
#' @param rm_extension Logical. If TRUE, removes file extensions from filenames. 
#'   Defaults to TRUE.
#' @param rm_path Logical. If TRUE, removes directory paths, keeping only the filename. 
#'   Defaults to TRUE.
#'
#' @details
#' The function performs the following operations:
#' \itemize{
#'   \item Validates input paths
#'   \item Handles empty input vectors
#'   \item Optionally removes directory paths using \code{\link[base]{basename}}
#'   \item Optionally removes file extensions using regex substitution
#' }
#'
#' @return A character vector of processed filenames
#'
#' @note
#' - If both \code{rm_extension} and \code{rm_path} are FALSE, 
#'   a warning is issued and the original paths are returned
#' - Supports multiple file paths in the input vector
#'
#' @seealso
#' \code{\link[base]{basename}} for extracting filenames
#'
#' @export
get_filename <- function(paths, rm_extension = TRUE, rm_path = TRUE) {

  # Input validation
  if (missing(paths)) {
    stop("Parameter 'paths' cannot be empty")
  }

  if (!is.character(paths)) {
    stop("'paths' must be a character vector")
  }

  # Handle empty vector
  if (length(paths) == 0) {
    return(character(0))
  }

  # Warn if both parameters are FALSE
  if (!rm_extension && !rm_path) {
    warning("Setting both rm_extension=FALSE and rm_path=FALSE returns the original paths")
  }

  # Process paths
  result <- if (rm_path) basename(paths) else paths

  # Process extensions
  if (rm_extension) {
    result <- sub("\\.[^.]*$", "", result)
  }

  return(result)
}
```
  
```{r example-get_filename}
xlsx_files <- mintyr_example(mintyr_examples("xlsx_test"))
xlsx_files
get_filename(xlsx_files) # Keep only file names
get_filename(xlsx_files, rm_extension = FALSE) # Keep extension
get_filename(xlsx_files, rm_path = FALSE) # Keep path
```


# w2l_nest
    
```{r function-w2l_nest}
#' Reshape Wide Data to Long Format and Nest by Specified Columns
#' 
#' The `w2l_nest` function reshapes wide-format data into long-format and nests it by specified columns.
#' It handles both `data.frame` and `data.table` objects and provides options for grouping and nesting the data.
#' 
#' @param data A `data.frame` or `data.table`. The input data in wide format.
#' @param cols2l A numeric or character vector. Specifies the columns to reshape from wide to long format.
#'   Can be either numeric indices or column names.
#' @param by An optional character vector. Specifies the columns to group by. Default is `NULL`.
#' @param nest_type A character string, either `"dt"` or `"df"`. Specifies the type of object to nest in the
#'   result: `"dt"` for `data.table`, `"df"` for `data.frame`. Default is `"dt"`.
#'
#' @return A `data.table` with nested data in long format, grouped by specified columns if provided.
#' Each row contains a nested data table or data frame under the column `data`, depending on `nest_type`.
#' \itemize{
#'   \item If `by` is `NULL`, returns a `data.table` nested by `name`.
#'   \item If `by` is specified, returns a `data.table` nested by `name` and the grouping variables.
#' }
#' 
#' @details
#' The function melts the specified wide columns into long format and nests the resulting data by the `name`
#' column and any additional grouping variables specified in `by`. The nested data can be in the form of
#' `data.table` or `data.frame` objects, controlled by the `nest_type` parameter.
#' 
#' @import data.table
#' 
#' @export
#' 
#' @note
#' \itemize{
#'   \item The `cols2l` parameter should be either numeric indices or a character vector of column names present in `data`.
#'   \item Ensure all grouping variables specified in `by` are present in `data`.
#'   \item The function converts `data.frame` to `data.table` if necessary.
#'   \item The `nest_type` parameter controls whether nested data are `data.table` (`"dt"`) or `data.frame` (`"df"`) objects.
#'   \item If `nest_type` is not `"dt"` or `"df"`, the function will stop with an error.
#' }
w2l_nest <- function(data, cols2l, by = NULL, nest_type = "dt") {
  . <- name <- NULL

  # Ensure the data is a data.table object
  if (!data.table::is.data.table(data)) {
    if (is.data.frame(data)) {
      data <- data.table::as.data.table(data)  # Convert data.frame to data.table if necessary
    } else {
      stop("Data must be either a data.frame or a data.table.")  # Stop if data is not a data.table or data.frame
    }
  }

  # Process grouping variables
  if (!is.null(by)) {
    missing_by_vars <- by[!by %in% names(data)]
    if (length(missing_by_vars) > 0) {
      stop("Grouping variables not present in data: ", paste(missing_by_vars, collapse=", "))
    }
  }

  # Check the validity of cols2l based on its type
  if (is.numeric(cols2l)) {
    if (any(cols2l < 1 | cols2l > ncol(data))) {
      stop("Numeric indices in cols2l are out of bounds.")  # Corrected the condition
    }
  } else if (is.character(cols2l)) {
    if (!all(cols2l %in% names(data))) {
      missing_cols <- cols2l[!cols2l %in% names(data)]
      stop("Some columns specified in cols2l are not present in the data: ", paste(missing_cols, collapse=", "))
    }
  } else {
    stop("cols2l should be either numeric indices or character vector of column names.")  # Ensure cols2l is either numeric or character
  }

  # Melt the data
  #id_vars <- setdiff(names(data), cols2l)  # Use all other columns as id variables
  melted_data <- data.table::melt(
    data,
    #id.vars = id_vars,
    measure.vars = cols2l,
    variable.name = "name",
    value.name = "value"
  )  # Melt the data using specified cols2l

  # Determine grouping variables for nesting
  if (!is.null(by) && length(by) > 0) {
    groupby <- c("name", by)
  } else {
    groupby <- "name"
  }

  # # Nest the data based on nest_type
  if (nest_type == "dt") {
    result <- melted_data[, .(data = list(.SD)), by = groupby]
  } else if (nest_type == "df") {
    result <- melted_data[, .(data = list(as.data.frame(.SD))), by = groupby]
  } else {
    stop("Invalid nest_type provided. It must be either 'dt' or 'df'.")
  }

  # Return the result
  return(result)
}
```
  
```{r example-w2l_nest}
w2l_nest(data = iris, cols2l = 1:4)
w2l_nest(data = iris, cols2l = c("Sepal.Length", "Sepal.Width", "Petal.Length"), by = "Species")
```
  
# w2l_split
    
```{r function-w2l_split}
#' Reshape Wide Data to Long Format and Split into List
#' 
#' The `w2l_split` function reshapes wide-format data into long-format and splits it into a list
#' by variable names and optional grouping columns. It handles both `data.frame` and `data.table` objects.
#' 
#' @param data A `data.frame` or `data.table`. The input data in wide format.
#' @param cols2l A numeric or character vector. Specifies the columns to reshape from wide to long format.
#'   Can be either numeric indices or column names.
#' @param by An optional character vector. Specifies additional columns to split by. Default is `NULL`.
#' @param split_type A character string, either `"dt"` or `"df"`. Specifies the type of objects in the
#'   resulting list: `"dt"` for `data.table`, `"df"` for `data.frame`. Default is `"dt"`.
#'
#' @return A list of `data.table` or `data.frame` objects (depending on `split_type`), split by variable
#' names and optional grouping columns.
#' \itemize{
#'   \item If `by` is `NULL`, returns a list split by variable names only.
#'   \item If `by` is specified, returns a list split by both variable names and grouping variables.
#' }
#' 
#' @details
#' The function first melts the specified wide columns into long format and then splits the resulting data
#' into a list based on the variable names and any additional grouping variables specified in `by`.
#' The resulting list elements can be either `data.table` or `data.frame` objects, as specified by
#' the `split_type` parameter.
#' 
#' @import data.table
#' 
#' @export
#' 
#' @note
#' \itemize{
#'   \item The `cols2l` parameter should be either numeric indices or a character vector of column names present in `data`.
#'   \item Ensure all grouping variables specified in `by` are present in `data`.
#'   \item The function automatically converts `data.frame` to `data.table` for processing.
#'   \item The `split_type` parameter determines the class of objects in the resulting list.
#'   \item Non-specified columns are automatically used as ID variables in the reshaping process.
#' }
w2l_split <- function(data, cols2l, by = NULL, split_type = "dt") {
  # Verify that data is provided and is either a data.frame or data.table
  if (!data.table::is.data.table(data)) {
    if (is.data.frame(data)) {
      data <- data.table::as.data.table(data)  # Convert data.frame to data.table
    } else {
      stop("data must be a data.frame or data.table.")
    }
  }

  # Verify that cols2l is provided and valid
  if (missing(cols2l)) stop("cols2l parameter is missing.")

  if (is.numeric(cols2l)) {
    if (any(cols2l < 1 | cols2l > ncol(data))) {
      stop("Numeric indices in cols2l are out of bounds.")  # Check if numeric indices are within data
    }
    cols2l_names <- names(data)[cols2l]
  } else if (is.character(cols2l)) {
    if (!all(cols2l %in% names(data))) {
      missing_cols <- cols2l[!cols2l %in% names(data)]
      stop("Some columns specified in cols2l are not present in the data: ", paste(missing_cols, collapse = ", "))
    }
    cols2l_names <- cols2l
  } else {
    stop("cols2l should be either numeric indices or character vector of column names.")  # Ensure cols2l is valid
  }

  # Verify that 'by' parameter is valid
  if (!is.null(by)) {
    if (!all(by %in% names(data))) {
      missing_by <- by[!by %in% names(data)]
      stop("Some 'by' columns are not present in the data: ", paste(missing_by, collapse = ", "))
    }
  }

  # Convert data from wide format to long format
  # Use columns not in cols2l as id.vars, ensure 'by' columns are included
  id_vars <- setdiff(names(data), cols2l_names)
  if (!is.null(by)) {
    id_vars <- unique(c(id_vars, by))  # Ensure 'by' columns are included in id.vars
  }

  dt_long <- data.table::melt(
    data,
    id.vars = id_vars,
    measure.vars = cols2l_names,
    variable.name = "variable",
    value.name = "value"
  )

  # Define variables to split by
  split_vars <- c("variable", by)

  # Split the long-format data.table into a list based on 'variable' and 'by' columns
  dt_list <- split(dt_long, by = split_vars, keep.by = F, drop = TRUE)

  # Convert list elements to data.frame if split_type is 'df'
  if (split_type == "dt") {
    # List elements are already data.tables, no action needed
  } else if (split_type == "df") {
    dt_list <- lapply(dt_list, as.data.frame)  # Convert each data.table to data.frame
  } else {
    stop("Invalid split_type provided. It must be either 'dt' or 'df'.")
  }

  # Return the result list
  return(dt_list)
}
```
  
```{r example-w2l_split}
w2l_split(data = iris, cols2l = 1:3)
w2l_split(data = iris, cols2l = c("Sepal.Length", "Sepal.Width"))
```
  
# combn_pair
    
```{r function-combn_pair}
#' Generate and Combine Column Pairs with Nested Data
#' 
#' @description
#' `combn_pair` generates combinations of specified columns, combines them, and nests the data.
#' It supports both data.table and data.frame inputs with optional grouping functionality.
#' 
#' @param data data.table or data.frame. The input dataset.
#' @param cols2bind character vector. Column names to be combined into pairs.
#' @param by character vector, optional. Column names for grouping. Default is NULL.
#' @param pairs_n integer, optional. Number of columns in each combination. 
#'        Must be >= 2 and <= length of cols2bind. Default is 2.
#' @param sep character, optional. Separator used when combining column names. Default is "-".
#' @param nest_type character, optional. Type of nested data to return: "dt" (data.table) or "df" (data.frame). Default is "dt".
#'
#' @return A nested data.table:
#' \itemize{
#'   \item When `by` is NULL: returns data.table nested by 'pairs'
#'   \item When `by` is specified: returns data.table nested by 'pairs' and grouping variables
#' }
#' 
#' @details
#' The function performs the following main steps:
#' 1. Validates input parameters
#' 2. Generates all possible combinations of specified columns
#' 3. Creates subsets for each combination and renames columns
#' 4. Merges all subsets and performs nesting
#'
#' @import data.table
#' @importFrom utils "combn"
#' 
#' @export
#' 
#' @note
#' Important considerations:
#' \itemize{
#'   \item cols2bind must be a character vector of existing column names
#'   \item pairs_n must be a positive integer >= 2 and <= number of columns in cols2bind
#'   \item sep must be a single character string
#'   \item Grouping variables in `by` must exist in the data
#'   \item nest_type must be either "dt" or "df"
#' }
combn_pair <- function(data, cols2bind, by = NULL, pairs_n = 2, sep = "-", nest_type = "dt") {
  . <- pairs <- NULL  # For data.table's NSE
  
  # Validate inputs
  if (!inherits(data, c("data.table", "data.frame"))) {
    stop("data must be a data.table or a data.frame")
  }
  data <- data.table::as.data.table(data)
  
  if (!is.character(cols2bind)) {
    stop("cols2bind must be a character vector")
  }
  missing_cols <- cols2bind[!cols2bind %in% names(data)]
  if (length(missing_cols) > 0) {
    stop("Some columns specified in cols2bind are not present in the data: ", paste(missing_cols, collapse=", "))
  }
  
  # Validate pairs_n
  if (!is.numeric(pairs_n) || pairs_n < 2 || floor(pairs_n) != pairs_n) {
    stop("pairs_n must be a positive integer greater than or equal to 2")
  }
  
  # Check if pairs_n is less than or equal to the number of available columns
  if (pairs_n > length(cols2bind)) {
    stop(sprintf("pairs_n (%d) cannot be larger than the number of available columns (%d)", 
                 pairs_n, length(cols2bind)))
  }
  
  if (!is.character(sep) || length(sep) != 1) {
    stop("sep must be a single character string")
  }
  
  if (!is.null(by)) {
    if (!is.character(by)) {
      stop("'by' must be a character vector of column names.")
    }
    missing_by_vars <- by[!by %in% names(data)]
    if (length(missing_by_vars) > 0) {
      stop("Grouping variables not present in data: ", paste(missing_by_vars, collapse=", "))
    }
  }
  
  if (!nest_type %in% c("dt", "df")) {
    stop("Invalid nest_type provided. It must be either 'dt' or 'df'.")
  }
  
  # Prepare data for combination operations
  dt <- data.table::copy(data)  # Copy the data to avoid modifying the original
  
  fixed_cols <- setdiff(names(dt), cols2bind)
  comb_cols_list <- combn(cols2bind, pairs_n, simplify=FALSE)
  
  list_of_dts <- lapply(comb_cols_list, function(comb) {
    dt_subset <- dt[, c(fixed_cols, comb), with=FALSE]
    # Create pairs identifier
    pairs_name <- paste(comb, collapse=sep)
    # Rename the combination columns to 'value1', 'value2', etc.
    data.table::setnames(dt_subset, comb, paste0('value', seq_along(comb)))
    # Add 'pairs' column
    dt_subset[, pairs := pairs_name]
    dt_subset
  })
  
  dt_bind <- data.table::rbindlist(list_of_dts)
  
  # Determine grouping variables
  if (!is.null(by) && length(by) > 0) {
    groupby <- c("pairs", by)
  } else {
    groupby <- "pairs"
  }
  
  # Nest the data based on nest_type
  if (nest_type == "dt") {
    result <- dt_bind[, .(data = list(.SD)), by = groupby]
  } else if (nest_type == "df") {
    result <- dt_bind[, .(data = list(as.data.frame(.SD))), by = groupby]
  } else {
    stop("Invalid nest_type provided. It must be either 'dt' or 'df'.")
  }
  
  return(result)
}
```
  
```{r example-combn_pair}
col_names <- c("Sepal.Length", "Sepal.Width", "Petal.Length")
combn_pair(iris, cols2bind = col_names, pairs_n = 2, sep = "&")
combn_pair(iris, cols2bind = col_names, pairs_n = 2, by = "Species")
```
  
# nest_cv
    
```{r function-nest_cv}
#' Apply Cross-Validation to Nested Data
#'
#' The `nest_cv` function applies cross-validation splits to nested data frames or data tables within a data table. It uses the `rsample` package's `vfold_cv` function to create cross-validation splits for predictive modeling and analysis on nested datasets.
#'
#' @param nest_dt A `data.frame` or `data.table` that contains at least one nested column of `data.frame`s or `data.table`s. The input data where cross-validation will be applied.
#' @inheritParams rsample::vfold_cv
#'
#' @return A `data.table` containing the cross-validation splits for each nested dataset. It includes:
#' \itemize{
#'   \item Original non-nested columns from `nest_dt`.
#'   \item `splits`: The cross-validation split objects returned by `rsample::vfold_cv`.
#'   \item `train`: The training data for each split.
#'   \item `validate`: The validation data for each split.
#' }
#'
#' @seealso [rsample::vfold_cv()] 
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Checks if the input `nest_dt` is non-empty and contains at least one nested column of `data.frame`s or `data.table`s.
#'   \item Identifies the nested columns and non-nested columns within `nest_dt`.
#'   \item Applies `rsample::vfold_cv` to each nested data frame in the specified nested column(s), creating the cross-validation splits.
#'   \item Expands the cross-validation splits and associates them with the non-nested columns.
#'   \item Extracts the training and validation data for each split and adds them to the output data table.
#' }
#'
#' If the `strata` parameter is provided, stratified sampling is performed during the cross-validation. Additional arguments can be passed to `rsample::vfold_cv` via `...`.
#'
#' @import data.table
#' @importFrom rsample vfold_cv training testing
#' @export
#'
#' @note
#' \itemize{
#'   \item The `nest_dt` must contain at least one nested column of `data.frame`s or `data.table`s.
#'   \item The function converts `nest_dt` to a `data.table` internally to ensure efficient data manipulation.
#'   \item The `strata` parameter should be a column name present in the nested data frames.
#'   \item If `strata` is specified, ensure that the specified column exists in all nested data frames.
#'   \item The `breaks` and `pool` parameters are used when `strata` is a numeric variable and control how stratification is handled.
#'   \item Additional arguments passed through `...` are forwarded to `rsample::vfold_cv`.
#' }
nest_cv <- function(nest_dt, v = 10, repeats = 1, strata = NULL, breaks = 4, pool = 0.1, ...) {
  cv_split <- data <- splits <- NULL

  # Check if input is empty
  if (nrow(nest_dt) == 0) {
    stop("The input nest_dt cannot be empty")
  }

  # Check for nested data.frame or data.table columns
  nested_cols <- names(nest_dt)[sapply(nest_dt, function(x) {
    is.list(x) && all(sapply(x, function(y) {
      inherits(y, c("data.frame", "data.table"))
    }))
  })]

  if (length(nested_cols) == 0) {
    stop("The input nest_dt must contain at least one nested column of data.frames or data.tables")
  }

  # Copy input data to avoid modifying original data
  dt <- data.table::copy(nest_dt)

  # Identify nested list columns
  is_nested_list <- sapply(dt, function(x) all(vapply(x, is.list, logical(1))))

  # Get non-nested column names
  non_nested_cols <- names(dt)[!is_nested_list]

  # Apply cross-validation
  dt[, cv_split := lapply(data, function(x) {
    if (!is.null(strata)) {
      rsample::vfold_cv(data = x, v = v, repeats = repeats,
                        strata = strata,  # 直接传递 strata 变量名
                        breaks = breaks, pool = pool, ...)
    } else {
      rsample::vfold_cv(data = x, v = v, repeats = repeats,
                        breaks = breaks, pool = pool, ...)
    }
  })
  ][, cv_split[[1]], by = non_nested_cols
  ][, ':='(train = lapply(splits, \(x) rsample::training(x)),
           validate = lapply(splits, \(x) rsample::testing(x)))][]
}
```
  
```{r example-nest_cv}
dt_nest <- w2l_nest(data = iris, cols2l = 1:2, by = "Species")
nest_cv(nest_dt = dt_nest, v = 2, repeats = 2)
```
  
  
# top_perc
    
```{r function-top_perc}
#' Select Top Percentage of Data and Compute Summary Statistics
#' 
#' The `top_perc` function selects the top percentage of data based on a specified trait and computes summary statistics.
#' It allows for grouping by additional columns and offers flexibility in the type of statistics calculated.
#' The function can also retain the selected data if needed.
#' 
#' @param data data.frame. The input data frame.
#' @param perc numeric vector. A vector of percentages to select the top data. Each element should be a numeric value between -1 and 1.
#' @param trait character. The name of the column in `data` on which to base the selection.
#' @param by character vector, optional. The names of the columns to group by. Default is NULL.
#' @inheritParams rstatix::get_summary_stats
#' @param keep_data logical, optional. If TRUE, the function returns both the summary statistics and the selected top data. Default is FALSE.
#'
#' @return A list or data frame:
#' \itemize{
#'   \item If `keep_data` is FALSE, a data frame with summary statistics.
#'   \item If `keep_data` is TRUE, a list where each element is a list containing summary statistics (`stat`) and the selected top data (`data`).
#' }
#' 
#' @export
#' 
#' @note
#' \itemize{
#'   \item The `perc` parameter accepts values between -1 and 1. Positive values select the top percentage, while negative values select the bottom percentage.
#'   \item The function performs initial checks to ensure required arguments are provided and valid.
#'   \item Grouping by additional columns (`by`) is optional and allows for more granular analysis.
#'   \item The `type` parameter specifies the type of summary statistics to compute, with "mean_sd" as the default.
#'   \item If `keep_data` is set to TRUE, the function will return both the summary statistics and the selected top data for each percentage.
#' }
top_perc <- function(data, perc, trait, by = NULL, type = "mean_sd", keep_data = FALSE) {
  # Initial checks and data preparation
  missing_args <- c()
  if (missing(data)) missing_args <- c(missing_args, "data")
  if (missing(perc)) missing_args <- c(missing_args, "perc")
  if (missing(trait)) missing_args <- c(missing_args, "trait")

  if (length(missing_args) > 0) {
    stop("Error: Missing argument(s): ", paste(missing_args, collapse=", "))
  }

  if (!inherits(data, "data.frame")) {
    message("Converting 'data' to data.frame")
    data <- as.data.frame(data)
  }

  # Ensure 'perc' is treated as a numeric vector
  perc <- as.numeric(perc)
  if (length(perc) == 0) {
    stop("Error: 'perc' must not be empty.")
  }
  if (any(perc < -1 | perc > 1)) {
    stop("Error: Each element of 'perc' must be a numeric value between -1 and 1.")
  }

  if (!trait %in% names(data)) {
    stop("Error: 'trait' must be a valid column name in 'data'.")
  }

  if (!is.null(by) && !all(by %in% names(data))) {
    stop("Error: 'by' must contain valid column names in 'data'.")
  }

  # Processing each percentage
  results <- purrr::map(perc, function(p) {
    grouped_data <- if (!is.null(by) && length(by) > 0) {
      data |> dplyr::group_by(dplyr::across(dplyr::all_of(by)))
    } else {
      data
    }

    top_data <- grouped_data |>
      dplyr::top_frac(p, !!rlang::sym(trait))

    # Always compute stats
    stats <- top_data |>
      rstatix::get_summary_stats(!!rlang::sym(trait), type = type) |>
      dplyr::mutate(top_perc = paste0(p * 100, "%"))

    # Return both stats and data if keep_data is TRUE
    if (keep_data) {
      list(stat = stats, data = top_data)
    } else {
      list(stat = stats)
    }
  }) |>
    purrr::set_names(paste(trait, perc, sep = "_"))

  # Simplify the output structure based on what is available in each result
  if (keep_data) {
    results
  } else {
    results <- purrr::map(results, "stat") |> purrr::list_rbind()
  }

  return(results)
}
```
  
```{r example-top_perc}
top_perc(iris, perc = 0.5, trait = "Petal.Width", by = "Species")
```
  



That's it ! This the end of the documented story of our package. All components are there.

<!-- 
# Inflate your package

You're one inflate from paper to box.
Build your package from this very Rmd using `fusen::inflate()` 
-->


```{r development-inflate, eval=FALSE}
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_teaching.Rmd")
```

<!-- 
- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory 
-->
